/*
 * Copyright 2017-2020 original authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.micronaut.http.netty.channel.converters;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import io.netty.channel.ChannelOption;
import io.netty.channel.epoll.EpollChannelOption;
import io.netty.channel.kqueue.KQueueChannelOption;

import org.gradle.api.DefaultTask;
import org.gradle.api.tasks.TaskAction;

/**
 * Build ChannelOptions classes.
 *
 * @author croudet
 */
public class ChannelOptionsTask extends DefaultTask {

    private static String indent(int nb) {
        String indent = "";
        for (int i = 0; i < nb; i++) {
            indent += "    ";
        }
        return indent;
    }

    private static final String CLASS_ANNOTATIONS = "@Singleton\r\n@Internal";

    private static final String IMPORTS = "import java.util.Optional;\r\n"
            + "import io.netty.channel.ChannelOption;\r\n" + "import io.micronaut.core.annotation.Internal;\r\n"
            + "import javax.inject.Singleton;";

    private static final String CLASS_COMMENT = "/**\r\n" + " * Returns the ChannelOption argument type.\r\n" + " *\r\n"
            + " * @author autogenerated class\r\n" + " */";

    private static final String LICENSE = "/*\r\n" + " * Copyright 2017-2020 original authors\r\n" + " *\r\n"
            + " * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n"
            + " * you may not use this file except in compliance with the License.\r\n"
            + " * You may obtain a copy of the License at\r\n" + " *\r\n"
            + " * http://www.apache.org/licenses/LICENSE-2.0\r\n" + " *\r\n"
            + " * Unless required by applicable law or agreed to in writing, software\r\n"
            + " * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n"
            + " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n"
            + " * See the License for the specific language governing permissions and\r\n"
            + " * limitations under the License.\r\n" + " */";

    /**
     * Builds ChannelOptions classes
     */
    @TaskAction
    public void buildChannelOptionsClasses() throws IOException {
        Path projectPath = getProject().getProjectDir().toPath();
        Path destinationPath = projectPath.resolve("src").resolve("main").resolve("java").resolve("io")
                .resolve("micronaut").resolve("http").resolve("netty").resolve("channel").resolve("converters");
        if (!Files.exists(destinationPath)) {
            getProject().getLogger().error("Fail to find " + destinationPath);
        }
        Set<String> names = new HashSet<>();
        try (PrintWriter w = new PrintWriter(
                Files.newBufferedWriter(destinationPath.resolve("DefaultChannelOptions.java"), StandardCharsets.UTF_8,
                        StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE))) {
            channelOptions(w, names,
                    new ClassSpec(
                            ChannelOption.class,
                            "import io.micronaut.context.annotation.Primary;",
                            "@Primary",
                            "DefaultChannelOptions implements ChannelOptions",
                            "Optional.empty();"));
        }
        try (PrintWriter w = new PrintWriter(
                Files.newBufferedWriter(destinationPath.resolve("EpollChannelOptions.java"), StandardCharsets.UTF_8,
                        StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE))) {
            channelOptions(w, new HashSet<>(names),
                    new ClassSpec(
                            EpollChannelOption.class,
                            "import javax.inject.Named;",
                            "@Named(\"" + EpollChannelOption.class.getSimpleName() + "s\")",
                            EpollChannelOption.class.getSimpleName() + "s extends DefaultChannelOptions",
                            "super.channelOptionType(option);"));
        }
        try (PrintWriter w = new PrintWriter(
                Files.newBufferedWriter(destinationPath.resolve("KQueueChannelOptions.java"), StandardCharsets.UTF_8,
                        StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE))) {
            channelOptions(w, new HashSet<>(names),
                    new ClassSpec(
                            KQueueChannelOption.class,
                            "import javax.inject.Named;",
                            "@Named(\"" + KQueueChannelOption.class.getSimpleName() + "s\")",
                            KQueueChannelOption.class.getSimpleName() + "s extends DefaultChannelOptions",
                            "super.channelOptionType(option);"));
        }
    }

    private static class ClassSpec {
        Class channelOptionClass;
        String imports;
        String annotations;
        String classSpec;
        String defaultCase;

        ClassSpec(Class channelOptionClass, String imports, String annotations, String classSpec, String defaultCase) {
            this.channelOptionClass = channelOptionClass;
            this.imports = imports;
            this.annotations = annotations;
            this.classSpec = classSpec;
            this.defaultCase = defaultCase;
        }
    }

    private static Optional<String> optionName(Field field) {
        try {
            return Optional.of(((ChannelOption) field.get(null)).name());
        } catch (IllegalArgumentException | IllegalAccessException e) {
            return Optional.empty();
        }
    }

    private static List<Field> getChannelOptionsFields(Class<?> c) {
        List<Field> result = new ArrayList<>();
        Field[] fields = c.getFields();
        int m = 0x0 | Modifier.STATIC | Modifier.PUBLIC;
        for (Field field : fields) {
            if ((field.getModifiers() & m) == m && field.getType().equals(ChannelOption.class)) {
                result.add(field);
            }
        }
        try {
            result.sort((f1, f2) -> optionName(f1).get().compareTo(optionName(f2).get()));
        } catch (Throwable t) {
            result.sort((f1, f2) -> f1.getName().compareTo(f2.getName()));
        }
        return result;
    }

    private static Optional<Class> resolveGenericTypeArgument(Field field) {
        Type genericType = field != null ? field.getGenericType() : null;
        if (genericType instanceof ParameterizedType) {
            Type[] typeArguments = ((ParameterizedType) genericType).getActualTypeArguments();
            if (typeArguments.length > 0) {
                Type typeArg = typeArguments[0];
                return resolveParameterizedTypeArgument(typeArg);
            }
        }
        return Optional.empty();
    }

    private static Optional<Class> resolveParameterizedTypeArgument(Type actualTypeArgument) {
        ParameterizedType pt;
        if (actualTypeArgument instanceof Class) {
            return Optional.of((Class) actualTypeArgument);
        }
        if (actualTypeArgument instanceof ParameterizedType) {
            pt = (ParameterizedType) actualTypeArgument;
            Type rawType = pt.getRawType();
            if (rawType instanceof Class) {
                return Optional.of((Class) rawType);
            }
        }
        return Optional.empty();
    }

    private void dumpOptions(String indent, PrintWriter out, Set<String> optionNames, Class channelOptionClass) {
        List<Field> options = getChannelOptionsFields(channelOptionClass);
        for (Field option : options) {
            if (!optionNames.add(option.getName())) {
                continue;
            }
            Optional<Class> typeArg = resolveGenericTypeArgument(option);
            Optional<String> name = optionName(option);
            if (typeArg.isPresent() && name.isPresent()) {
                out.println(indent + "case \"" + name.get() + "\": return Optional.of(" + typeArg.get().getName()
                        + ".class);");
            } else {
                getProject().getLogger().error(option + " type Not Found");
            }
        }
    }

    private void channelOptions(PrintWriter out, Set<String> optionNames, ClassSpec spec) {
        int i = 0;
        out.println(LICENSE);
        out.println("package io.micronaut.http.netty.channel.converters;");
        out.println();
        out.println(IMPORTS);
        out.println(spec.imports);
        out.println();
        out.println(CLASS_COMMENT);
        out.println(CLASS_ANNOTATIONS);
        out.println(spec.annotations);
        out.println("public class " + spec.classSpec + " {");
        out.println();
        ++i;
        out.println(indent(i) + "@Override");
        out.println(indent(i) + "public Optional<Class> channelOptionType(ChannelOption<?> option) {");
        ++i;
        out.println(indent(i) + "switch (option.name()) {");
        ++i;
        dumpOptions(indent(i), out, optionNames, spec.channelOptionClass);
        out.println(indent(i) + "default: return " + spec.defaultCase);
        --i;
        out.println(indent(i) + "}");
        --i;
        out.println(indent(i) + "}");
        --i;
        out.println(indent(i) + "}");
    }
}
